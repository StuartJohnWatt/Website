[{"authors":["admin"],"categories":null,"content":"I am currently a student at Robert Gordon University studying Data Science with The Data Lab MSc scholarship. My interests include scripting in a variety of languages, usually with the aim of extracting knowledge from data or modeling and simulating various phemonema.\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"I am currently a student at Robert Gordon University studying Data Science with The Data Lab MSc scholarship. My interests include scripting in a variety of languages, usually with the aim of extracting knowledge from data or modeling and simulating various phemonema.","tags":null,"title":"Stuart John Watt","type":"authors"},{"authors":null,"categories":[],"content":"\rConsider a point \\(P_1\\) alongside another point \\(P_2\\) which lies below, but not directly below it. Which path allows a bead initially at rest, to slide frictionlessly from \\(P_1\\) to \\(P_2\\) with the least possible time \\(t\\) when subject to a constant downward gravitational force? This is known as the Brachistochrone problem and it is famous in the development of calculus.\n\rFigure 1: Simulated motion for different paths (time not to scale)\r\rThe solution to this problem is the Brachistochrone curve, which was found to be a cycloid. A cycloid is a path which is described by a point on a circle rolling along a flat surface.\n\rFigure 2: Cycloid traced by its generating circle. The Brachistochrone curve has the cusps pointed upward.\r\rI was interested in investigating this numerically, so I started to write a script simulating a bead falling down a path made of \\(N\\) line segments. Details are found below, but in summary the simulation was successful with the predicted time quickly converging with increasing number of line segments \\(N\\).\n\rFigure 3: Simulated time (in seconds) taken for bead to travel across Brachistochrone path approximated with \\(N\\) line segments between \\(P_1=(0,0.3)\\) and \\(P_2=(1,0)\\) in meters.\r\rSince the Brachistochrone problem is about finding a global minima an approximate solution should in principle be found via an optimisation algorithm. I used an optimisation algorithm to minimise the simulated travel time by varying the \\(y\\)-coordinates of an intermediate set of points initially making up a straight line segment from \\(P_1\\) to \\(P_2\\). The \\(x\\)-coordinates of these points remained fixed at equal values to the parametrisation of the known Brachistochrone curve. By recording the \\(y\\)-values for every function call the following animation was made.\n\rFigure 4: Progressive paths considered by optimisation method when finding fastest path of descent (shown in black) against known solution (shown in red).\r\rLooks good! So we can indeed find an approximate solution numerically without prior knowledge.\nCode\rFor the Brachistochrone trajectory, we use the set of parametric equations for a cycloid:\r\\[x(\\theta) = x_0+R(\\theta-\\sin\\theta),\\quad y(\\theta)=y_0+R(\\cos\\theta-1).\\]\rNote that the \\(y(\\theta)\\) is in a slightly different form than usual. I prefer having my \\(y\\) axis pointing vertically upwards (and hence, against gravity), so I use these equations are for an “upside down” cycloid.\nWe need to find the interval to vary \\(\\theta\\) over, along with \\(x_0\\), \\(y_0\\) and \\(R\\). Setting an initial \\(\\theta_0 = 0\\) gives \\(x=x_0\\) and \\(y=y_0\\): these are components of \\(P_1\\). Dividing one parametric equation by the other before rearranging, we obtain\r\\[\\frac{x(\\theta)-x_0}{y(\\theta)-y_0}-\\frac{\\theta-\\sin\\theta}{\\cos\\theta-1}=0.\\]\rWe can solve this numerically at \\(P_2\\) to find the upper range of the parameter value \\(\\theta_1\\). Finally, \\(R\\) can be found by simple substitution.\nI create a function to obtain Brachistochrone paths approximated over \\(N\\) segments with boundary conditions at the coordinates \\(P_1\\) and \\(P_2\\). This is returned in a data frame with a time column containing missing values. I also create two similar functions for straight and polygonal paths.\ngetBrachTraj \u0026lt;- function(P1, P2, N){\rtheta.i \u0026lt;- 0 theta.f \u0026lt;- uniroot(function(theta) (P2[1]-P1[1])/(P2[2]-P1[2]) - (theta-sin(theta))/(cos(theta)-1),\rinterval = c(10e-6, 2*pi), # we don\u0026#39;t use 0 to avoid devision by zero\rextendInt = c(\u0026quot;upX\u0026quot;),\rtol = 10e-10)$root\rtheta \u0026lt;- seq(theta.i, theta.f, length.out = N+1)\rR \u0026lt;- (P2[2]-P1[2])/(cos(theta.f)-1)\rdata.frame(x = P1[1]+R*(theta-sin(theta)),\ry = P1[2]+R*(cos(theta)-1),\rv = rep(NA, times = N+1),\ra = rep(NA, times = N+1),\rt = rep(NA, times = N+1))\r}\rgetLinTraj \u0026lt;- function(P1, P2, N){\rdata.frame(x = seq(from = P1[1], to = P2[1], length.out = N+1),\ry = seq(from = P1[2], to = P2[2], length.out = N+1),\rv = rep(NA, times = N+1),\ra = rep(NA, times = N+1),\rt = rep(NA, times = N+1))\r}\rgetPolygonalTraj \u0026lt;- function(P1,P2, N){\rh \u0026lt;- abs(P2[2]-P1[2])\rL \u0026lt;- abs(P2[1]-P1[1])\rn1 \u0026lt;- ceiling(h/(h+L)*(N+1))\rn2 \u0026lt;- N+2-n1\rdata.frame(x = c(rep(P1[1], times = n1),\rseq(P1[1], P2[1], length.out = n2)[2:n2]),\ry = c(seq(P1[2], P2[2], length.out = n1),\rrep(P2[2], times = n2)[2:n2]),\rv = rep(NA, times = N+1),\ra = rep(NA, times = N+1),\rt = rep(NA, times = N+1))\r}\rWe can now create a function that takes our trajectory data frame from above and fills the velocity, acceleration and time attributes. Here we just have \\(N\\) cases of simple inclined plane problems. By finding the segment distances and the accelerations dependent on the slope of the segments, we can calculate speeds of the bead entering and exiting each segment, thus allowing us to calculate the progress of time and store it in our data frame.\nmotion \u0026lt;- function(traj){\rif(any(traj$y[2:nrow(traj)] \u0026gt;= traj$y[1])) stop(\u0026quot;Improper path\u0026quot;)\rN \u0026lt;- nrow(traj)-1\ra \u0026lt;- rep(NA, N+1)\rg \u0026lt;- 9.81\rtraj$t[1] \u0026lt;- 0\rtraj$v[1] \u0026lt;- 0\rsegLengths \u0026lt;- sqrt(diff(traj$x)^2 + diff(traj$y)^2)\rtraj$a[1:(nrow(traj)-1)] \u0026lt;- g*(-1)*diff(traj$y) / segLengths\rgetSegTime \u0026lt;- function(d,v0,a){\rif(a == 0){\rreturn(d/v0)\r}else{\rreturn((sqrt(v0^2+2*a*d)-v0)/a)\r}\r}\rfor(ii in 2:nrow(traj)){\rdt \u0026lt;- getSegTime(d = segLengths[ii-1], v0 = traj$v[ii-1],\ra = traj$a[ii-1])\rtraj$t[ii] \u0026lt;- traj$t[ii-1] + dt\rtraj$v[ii] \u0026lt;- traj$v[ii-1] + traj$a[ii-1]*dt\r}\rreturn(traj)\r}\rSimulation for our three paths is now possible.\nN \u0026lt;- 50\rP1 \u0026lt;- c(0,0.3)\rP2 \u0026lt;- c(1,0)\rlin.motion \u0026lt;- motion(getLinTraj(P1,P2,N))\rbrach.motion \u0026lt;- motion(getBrachTraj(P1,P2,N))\rpolygon.motion \u0026lt;- motion(getPolygonalTraj(P1,P2,N))\rFor our animation we have a slight problem: each of these data frames will almost certainly each have a set of unique \\(t\\) values (ignoring \\(t=0\\)). This means that for a given moment in time we do not know their positions. We can solve this problem by writing a function that takes a motion data frame along with a vector of \\(t\\) values and outputs an updated data frame containing rows with \\(t\\). Since our simulation involves a collection of small inclined planes, we can calculate the required information for any time \\(t\u0026#39;\\) using any data with the closest \\(t\\) before and after.\ngetStates \u0026lt;- function(t,traj){\rN \u0026lt;- nrow(traj)-1\rn.new \u0026lt;- length(t)\ridx \u0026lt;- findInterval(t, traj$t)\rnewVal \u0026lt;- data.frame(x = rep(NA, times = n.new),\ry = rep(NA, times = n.new),\rv = rep(NA, times = n.new),\ra = rep(NA, times = n.new),\rt = t)\rfor(ii in 1:n.new){\rif(idx[ii] == N+1){\rnewVal$x[ii] \u0026lt;- traj$x[N+1]\rnewVal$y[ii] \u0026lt;- traj$y[N+1]\rnewVal$v[ii] \u0026lt;- 0\rnewVal$a[ii] \u0026lt;- 0\r}else{\rt0 \u0026lt;- traj$t[idx[ii]]\rdt \u0026lt;- t[ii]-t0\rds \u0026lt;- traj$v[idx[ii]]*dt + 0.5*traj$a[idx[ii]]*dt^2 # s = u*t + 1/2*a*t^2\rorig.segLength \u0026lt;- sqrt(diff(traj$x[idx[ii]:(idx[ii]+1)])^2+diff(traj$y[idx[ii]:(idx[ii]+1)])^2)\rnewVal$x[ii] \u0026lt;- traj$x[idx[ii]] + ds*(traj$x[idx[ii]+1]-traj$x[idx[ii]])/orig.segLength\rnewVal$y[ii] \u0026lt;- traj$y[idx[ii]] + ds*(traj$y[idx[ii]+1]-traj$y[idx[ii]])/orig.segLength\rnewVal$v[ii] \u0026lt;- traj$v[idx[ii]] + traj$a[idx[ii]]*dt\rnewVal$a[ii] \u0026lt;- traj$a[idx[ii]]\r}\r}\rout.df \u0026lt;- rbind(traj, newVal)\rreturn(out.df[order(out.df$t),])\r}\rtimes \u0026lt;- c(lin.motion$t, brach.motion$t, polygon.motion$t)\rlin.motion \u0026lt;- getStates(t = times, lin.motion)\rbrach.motion \u0026lt;- getStates(t = times, brach.motion)\rpolygon.motion \u0026lt;- getStates(t = times, polygon.motion)\rNow we can assemble the data and produce our animation:\nlibrary(tidyverse)\rlibrary(gganimate)\rlibrary(gifski)\rlin.motion$name \u0026lt;- \u0026quot;Linear\u0026quot;\rbrach.motion$name \u0026lt;- \u0026quot;Brachistochrone\u0026quot;\rpolygon.motion$name \u0026lt;- \u0026quot;Polygon\u0026quot;\rmotion.data \u0026lt;- rbind(lin.motion, brach.motion, polygon.motion)\ranim \u0026lt;- ggplot() +\rgeom_path(data = select(motion.data, x, y, name), aes(x, y, colour = name)) +\rgeom_point(data = motion.data, aes(x,y, fill = name), shape = 21, colour = \u0026quot;black\u0026quot;,\rsize = 4) +\rguides(fill = guide_legend(title = NULL), colour = guide_legend(title = NULL)) +\rcoord_fixed() +\rtransition_time(t) +\rshadow_wake(wake_length = 0.1)\ranim \u0026lt;- animate(anim, renderer = gifski_renderer(),\rduration = 3, end_pause = 25, fps = 30, res = 100,\rwidth = 650, height = 250)\rNow, to perform the optimisation, we first need to set up our Brachistochrone path.\nP1 \u0026lt;- c(0,0.3)\rP2 \u0026lt;- c(1,0)\rN \u0026lt;- 30 # Number of line segments\rbrach.path \u0026lt;- motion(getBrachTraj(P1,P2,N))\rbrach.path$t \u0026lt;- NULL\rbrach.path$name \u0026lt;- NULL\rbrach.path$v \u0026lt;- NULL\rbrach.path$a \u0026lt;- NULL\rWe create a matrix to store the intermediate \\(y\\)-values as rows, along with a wrapper function that takes these along with the \\(x\\)-values and end points of our path before returning the total time taken. Every time this function is called, the inserted \\(y\\)-values are stored into our matrix.\nmax.iter \u0026lt;- 100000L # maximum number of iterations for convergence method\rintermed.y.count \u0026lt;- 0L\rintermed.y \u0026lt;- matrix(as.numeric(NA), ncol = N+1, nrow = max.iter)\rgetTime \u0026lt;- function(intermed.heights, inx, P1, P2){\rintermed.y.count \u0026lt;\u0026lt;- intermed.y.count + 1L\rintermed.y[intermed.y.count,] \u0026lt;\u0026lt;- c(P1[2],intermed.heights,P2[2])\rN \u0026lt;- length(intermed.heights)+1\rtraj \u0026lt;- data.frame(x = inx,\ry = intermed.y[intermed.y.count,],\rv = rep(NA, times = N+1),\ra = rep(NA, times = N+1),\rt = rep(NA, times = N+1))\rreturn(motion(traj)$t[nrow(traj)])\r}\rNow we may apply the optimisation function.\nset.seed(1) # for reproducability\rminima \u0026lt;- optim(par = seq(P1[2],P2[2], length.out = N+1)[2:N],\rfn = getTime,\rlower = rep(-5, times = N-1),\rupper = rep(P1[2]-1e-5, times = N-1),\rmethod = \u0026quot;L-BFGS-B\u0026quot;,\rinx = brach.path$x,\rP1 = P1,\rP2 = P2)\rFinally, we can create the animation:\ny \u0026lt;- as.vector(intermed.y[1:intermed.y.count,])\rx \u0026lt;- rep(brach.path$x,\rtimes = rep(intermed.y.count, N+1))\riter \u0026lt;- rep(1:intermed.y.count, times = N+1)\rplot.data \u0026lt;- data.frame(x = x, y = y, iter = iter)\ranim.optim \u0026lt;- ggplot() +\rgeom_path(data = brach.path, aes(x = x, y = y), colour = \u0026quot;red\u0026quot;) +\rgeom_point(data = brach.path, aes(x = x, y = y), colour = \u0026quot;red\u0026quot;) +\rgeom_path(data = plot.data, aes(x = x, y = y)) +\rgeom_point(data = plot.data, aes(x = x, y = y)) +\rcoord_fixed() +\rylim(min(c(brach.path$y,plot.data$y)), max(c(brach.path$y,plot.data$y))) +\rtransition_time(iter)\ranim.optim \u0026lt;- animate(anim.optim, renderer = gifski_renderer(),\rduration = 10, end_pause = 5, fps = 20, res = 100,\rwidth = 800, height = 400)\r\r","date":1581724800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1581724800,"objectID":"6bf39cafc451f8385b00454112040030","permalink":"/post/brachistochrone/","publishdate":"2020-02-15T00:00:00Z","relpermalink":"/post/brachistochrone/","section":"post","summary":"Consider a point \\(P_1\\) alongside another point \\(P_2\\) which lies below, but not directly below it. Which path allows a bead initially at rest, to slide frictionlessly from \\(P_1\\) to \\(P_2\\) with the least possible time \\(t\\) when subject to a constant downward gravitational force? This is known as the Brachistochrone problem and it is famous in the development of calculus.\n\rFigure 1: Simulated motion for different paths (time not to scale)\r\rThe solution to this problem is the Brachistochrone curve, which was found to be a cycloid.","tags":["Physics","Simulation","Optimisation","Animation","R"],"title":"The Brachistochrone","type":"post"}]