[{"authors":["admin"],"categories":null,"content":"I am currently a student at Robert Gordon University studying Data Science with The Data Lab MSc scholarship. My interests include scripting in a variety of languages, usually with the aim of extracting knowledge from data or modelling and simulating various phenomena.\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"I am currently a student at Robert Gordon University studying Data Science with The Data Lab MSc scholarship. My interests include scripting in a variety of languages, usually with the aim of extracting knowledge from data or modelling and simulating various phenomena.","tags":null,"title":"Stuart John Watt","type":"authors"},{"authors":null,"categories":[],"content":"\r\r\r\rOver the past few weeks the Coronavirus (or more precisely COVID-19) outbreak has been consistently the centre of attention. This pandemic has been met with an unprecedented response, with countries around the globe enforcing lock-down and social distancing measures in an attempt to slow and/or reduce its spread.\nAs a data science student, I’ve been interested in how much attention has been placed on the data itself. A steady stream of new data is communicated by media either in raw form or by visualisations to satisfy the public interest.\nI started doing some analysis and I thought I’d share some visualisations I’ve made.\nA few data sources are available, although the ones provided by John Hopkins, ECDC and WHO seem to be the most popular. I initially used the former source, although I changed to using the ECDC data due to consistency issues. A good discussion of the datasets can be found in here.\nNote that this blog post is intended for interest only. Unlike many posts I’ve read, this isn’t about prediction or to argue which strategy or behaviour is best to mitigate the outbreak. I think too many enthusiasts have been overconfident in their interpretation of the data, which can be harmful given the seriousness of the situation. It’s best to listen to the professional scientists studying this, whether that be epidemiologists or from other fields. If you live in the UK, please follow the advice given by the NHS and UK Government!\nNote that I plan to update this page frequently to include recent data. This page currently has data up to 2020-05-12.\nFirst, a simple interactive plot of confirmed cases and fatalities against time. It’s important to remember that the data is for confirmed cases only. Due to limited testing the actual number of cases is considered to be much larger than the number of confirmed cases.\n\r{\"x\":{\"url\":\"/post/2020-03-28-covid-19-visualised/index_files/figure-html//widgets/widget_WorldTotalPlot.html\",\"options\":{\"xdomain\":\"*\",\"allowfullscreen\":false,\"lazyload\":false}},\"evals\":[],\"jsHooks\":[]}\rBubble plots have been popular to show the geographical spread. I wanted to visualise the spread of the disease with rate of new cases over time rather than just the total to date. Here is an animation of new confirmed cases against time and region. I used a rolling window to get 3-day sums to smooth out any daily jumps in the dataset caused by an artefact in the data collection process.\nFinally an interactive choropleth map. Regions are coloured according to a quantile ranking of the number of confirmed cases per million population. Since countries differ in their attitudes and capabilities for testing, it is important to be cautious when making comparisons between countries.\nEdit: As of 6th April, 2020 I am using a logarithmic colour scale instead of quantiles. Also I have added an option of switching the colouring between confirmed cases/deaths per million population.\n\r{\"x\":{\"url\":\"/post/2020-03-28-covid-19-visualised/index_files/figure-html//widgets/widget_MakeChoropleth.html\",\"options\":{\"xdomain\":\"*\",\"allowfullscreen\":false,\"lazyload\":false}},\"evals\":[],\"jsHooks\":[]}\r","date":1585353600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1585353600,"objectID":"beb156c176cfe881d012a8891f6b9891","permalink":"/post/2020-03-28-covid-19-visualised/","publishdate":"2020-03-28T00:00:00Z","relpermalink":"/post/2020-03-28-covid-19-visualised/","section":"post","summary":"Over the past few weeks the Coronavirus (or more precisely COVID-19) outbreak has been consistently the centre of attention. This pandemic has been met with an unprecedented response, with countries around the globe enforcing lock-down and social distancing measures in an attempt to slow and/or reduce its spread.\nAs a data science student, I’ve been interested in how much attention has been placed on the data itself.","tags":["coronavirus","covid-19","Animation","R"],"title":"COVID-19 Visualised","type":"post"},{"authors":null,"categories":[],"content":"\rConsider a point \\(P_1\\) alongside another point \\(P_2\\) which lies below, but not directly below it. Which path allows a bead initially at rest, to slide frictionlessly from \\(P_1\\) to \\(P_2\\) with the least possible time \\(t\\) when subject to a constant downward gravitational force? This is known as the Brachistochrone problem and it is famous in the development of calculus.\n\rFigure 1: Simulated motion for different paths (time not to scale)\r\rThe solution to this problem is the Brachistochrone curve, which was found to be a cycloid. A cycloid is a path which is described by a point on a circle rolling along a flat surface.\n\rFigure 2: Cycloid traced by its generating circle. The Brachistochrone curve has the cusps pointed upward.\r\rI was interested in investigating this numerically, so I started to write a script simulating a bead falling down a path made of \\(N\\) line segments. Details are found below, but in summary the simulation was successful with the predicted time quickly converging with increasing number of line segments \\(N\\).\n\rFigure 3: Simulated time (in seconds) taken for bead to travel across Brachistochrone path approximated with \\(N\\) line segments between \\(P_1=(0,0.3)\\) and \\(P_2=(1,0)\\) in meters.\r\rSince the Brachistochrone problem is about finding a global minima an approximate solution should in principle be found via an optimisation algorithm. I used an optimisation algorithm to minimise the simulated travel time by varying the \\(y\\)-coordinates of an intermediate set of points initially making up a straight line segment from \\(P_1\\) to \\(P_2\\). The \\(x\\)-coordinates of these points remained fixed at equal values to the parametrisation of the known Brachistochrone curve. By recording the \\(y\\)-values for every function call the following animation was made.\n\rFigure 4: Progressive paths considered by optimisation method when finding fastest path of descent (shown in black) against known solution (shown in red).\r\rLooks good! So we can indeed find an approximate solution numerically without prior knowledge.\nCode\rFor the Brachistochrone trajectory, we use the set of parametric equations for a cycloid:\r\\[x(\\theta) = x_0+R(\\theta-\\sin\\theta),\\quad y(\\theta)=y_0+R(\\cos\\theta-1).\\]\rNote that the \\(y(\\theta)\\) is in a slightly different form than usual. I prefer having my \\(y\\) axis pointing vertically upwards (and hence, against gravity), so I use these equations are for an “upside down” cycloid.\nWe need to find the interval to vary \\(\\theta\\) over, along with \\(x_0\\), \\(y_0\\) and \\(R\\). Setting an initial \\(\\theta_0 = 0\\) gives \\(x=x_0\\) and \\(y=y_0\\): these are components of \\(P_1\\). Dividing one parametric equation by the other before rearranging, we obtain\r\\[\\frac{x(\\theta)-x_0}{y(\\theta)-y_0}-\\frac{\\theta-\\sin\\theta}{\\cos\\theta-1}=0.\\]\rWe can solve this numerically at \\(P_2\\) to find the upper range of the parameter value \\(\\theta_1\\). Finally, \\(R\\) can be found by simple substitution.\nI create a function to obtain Brachistochrone paths approximated over \\(N\\) segments with boundary conditions at the coordinates \\(P_1\\) and \\(P_2\\). This is returned in a data frame with a time column containing missing values. I also create two similar functions for straight and polygonal paths.\ngetBrachTraj \u0026lt;- function(P1, P2, N){\rtheta.i \u0026lt;- 0 theta.f \u0026lt;- uniroot(function(theta) (P2[1]-P1[1])/(P2[2]-P1[2]) - (theta-sin(theta))/(cos(theta)-1),\rinterval = c(10e-6, 2*pi), # we don\u0026#39;t use 0 to avoid devision by zero\rextendInt = c(\u0026quot;upX\u0026quot;),\rtol = 10e-10)$root\rtheta \u0026lt;- seq(theta.i, theta.f, length.out = N+1)\rR \u0026lt;- (P2[2]-P1[2])/(cos(theta.f)-1)\rdata.frame(x = P1[1]+R*(theta-sin(theta)),\ry = P1[2]+R*(cos(theta)-1),\rv = rep(NA, times = N+1),\ra = rep(NA, times = N+1),\rt = rep(NA, times = N+1))\r}\rgetLinTraj \u0026lt;- function(P1, P2, N){\rdata.frame(x = seq(from = P1[1], to = P2[1], length.out = N+1),\ry = seq(from = P1[2], to = P2[2], length.out = N+1),\rv = rep(NA, times = N+1),\ra = rep(NA, times = N+1),\rt = rep(NA, times = N+1))\r}\rgetPolygonalTraj \u0026lt;- function(P1,P2, N){\rh \u0026lt;- abs(P2[2]-P1[2])\rL \u0026lt;- abs(P2[1]-P1[1])\rn1 \u0026lt;- ceiling(h/(h+L)*(N+1))\rn2 \u0026lt;- N+2-n1\rdata.frame(x = c(rep(P1[1], times = n1),\rseq(P1[1], P2[1], length.out = n2)[2:n2]),\ry = c(seq(P1[2], P2[2], length.out = n1),\rrep(P2[2], times = n2)[2:n2]),\rv = rep(NA, times = N+1),\ra = rep(NA, times = N+1),\rt = rep(NA, times = N+1))\r}\rWe can now create a function that takes our trajectory data frame from above and fills the velocity, acceleration and time attributes. Here we just have \\(N\\) cases of simple inclined plane problems. By finding the segment distances and the accelerations dependent on the slope of the segments, we can calculate speeds of the bead entering and exiting each segment, thus allowing us to calculate the progress of time and store it in our data frame.\nmotion \u0026lt;- function(traj){\rif(any(traj$y[2:nrow(traj)] \u0026gt;= traj$y[1])) stop(\u0026quot;Improper path\u0026quot;)\rN \u0026lt;- nrow(traj)-1\ra \u0026lt;- rep(NA, N+1)\rg \u0026lt;- 9.81\rtraj$t[1] \u0026lt;- 0\rtraj$v[1] \u0026lt;- 0\rsegLengths \u0026lt;- sqrt(diff(traj$x)^2 + diff(traj$y)^2)\rtraj$a[1:(nrow(traj)-1)] \u0026lt;- g*(-1)*diff(traj$y) / segLengths\rgetSegTime \u0026lt;- function(d,v0,a){\rif(a == 0){\rreturn(d/v0)\r}else{\rreturn((sqrt(v0^2+2*a*d)-v0)/a)\r}\r}\rfor(ii in 2:nrow(traj)){\rdt \u0026lt;- getSegTime(d = segLengths[ii-1], v0 = traj$v[ii-1],\ra = traj$a[ii-1])\rtraj$t[ii] \u0026lt;- traj$t[ii-1] + dt\rtraj$v[ii] \u0026lt;- traj$v[ii-1] + traj$a[ii-1]*dt\r}\rreturn(traj)\r}\rSimulation for our three paths is now possible.\nN \u0026lt;- 50\rP1 \u0026lt;- c(0,0.3)\rP2 \u0026lt;- c(1,0)\rlin.motion \u0026lt;- motion(getLinTraj(P1,P2,N))\rbrach.motion \u0026lt;- motion(getBrachTraj(P1,P2,N))\rpolygon.motion \u0026lt;- motion(getPolygonalTraj(P1,P2,N))\rFor our animation we have a slight problem: each of these data frames will almost certainly each have a set of unique \\(t\\) values (ignoring \\(t=0\\)). This means that for a given moment in time we do not know their positions. We can solve this problem by writing a function that takes a motion data frame along with a vector of \\(t\\) values and outputs an updated data frame containing rows with \\(t\\). Since our simulation involves a collection of small inclined planes, we can calculate the required information for any time \\(t\u0026#39;\\) using any data with the closest \\(t\\) before and after.\ngetStates \u0026lt;- function(t,traj){\rN \u0026lt;- nrow(traj)-1\rn.new \u0026lt;- length(t)\ridx \u0026lt;- findInterval(t, traj$t)\rnewVal \u0026lt;- data.frame(x = rep(NA, times = n.new),\ry = rep(NA, times = n.new),\rv = rep(NA, times = n.new),\ra = rep(NA, times = n.new),\rt = t)\rfor(ii in 1:n.new){\rif(idx[ii] == N+1){\rnewVal$x[ii] \u0026lt;- traj$x[N+1]\rnewVal$y[ii] \u0026lt;- traj$y[N+1]\rnewVal$v[ii] \u0026lt;- 0\rnewVal$a[ii] \u0026lt;- 0\r}else{\rt0 \u0026lt;- traj$t[idx[ii]]\rdt \u0026lt;- t[ii]-t0\rds \u0026lt;- traj$v[idx[ii]]*dt + 0.5*traj$a[idx[ii]]*dt^2 # s = u*t + 1/2*a*t^2\rorig.segLength \u0026lt;- sqrt(diff(traj$x[idx[ii]:(idx[ii]+1)])^2+diff(traj$y[idx[ii]:(idx[ii]+1)])^2)\rnewVal$x[ii] \u0026lt;- traj$x[idx[ii]] + ds*(traj$x[idx[ii]+1]-traj$x[idx[ii]])/orig.segLength\rnewVal$y[ii] \u0026lt;- traj$y[idx[ii]] + ds*(traj$y[idx[ii]+1]-traj$y[idx[ii]])/orig.segLength\rnewVal$v[ii] \u0026lt;- traj$v[idx[ii]] + traj$a[idx[ii]]*dt\rnewVal$a[ii] \u0026lt;- traj$a[idx[ii]]\r}\r}\rout.df \u0026lt;- rbind(traj, newVal)\rreturn(out.df[order(out.df$t),])\r}\rtimes \u0026lt;- c(lin.motion$t, brach.motion$t, polygon.motion$t)\rlin.motion \u0026lt;- getStates(t = times, lin.motion)\rbrach.motion \u0026lt;- getStates(t = times, brach.motion)\rpolygon.motion \u0026lt;- getStates(t = times, polygon.motion)\rNow we can assemble the data and produce our animation:\nlibrary(tidyverse)\rlibrary(gganimate)\rlibrary(gifski)\rlin.motion$name \u0026lt;- \u0026quot;Linear\u0026quot;\rbrach.motion$name \u0026lt;- \u0026quot;Brachistochrone\u0026quot;\rpolygon.motion$name \u0026lt;- \u0026quot;Polygon\u0026quot;\rmotion.data \u0026lt;- rbind(lin.motion, brach.motion, polygon.motion)\ranim \u0026lt;- ggplot() +\rgeom_path(data = select(motion.data, x, y, name), aes(x, y, colour = name)) +\rgeom_point(data = motion.data, aes(x,y, fill = name), shape = 21, colour = \u0026quot;black\u0026quot;,\rsize = 4) +\rguides(fill = guide_legend(title = NULL), colour = guide_legend(title = NULL)) +\rcoord_fixed() +\rtransition_time(t) +\rshadow_wake(wake_length = 0.1)\ranim \u0026lt;- animate(anim, renderer = gifski_renderer(),\rduration = 3, end_pause = 25, fps = 30, res = 100,\rwidth = 650, height = 250)\rNow, to perform the optimisation, we first need to set up our Brachistochrone path.\nP1 \u0026lt;- c(0,0.3)\rP2 \u0026lt;- c(1,0)\rN \u0026lt;- 30 # Number of line segments\rbrach.path \u0026lt;- motion(getBrachTraj(P1,P2,N))\rbrach.path$t \u0026lt;- NULL\rbrach.path$name \u0026lt;- NULL\rbrach.path$v \u0026lt;- NULL\rbrach.path$a \u0026lt;- NULL\rWe create a matrix to store the intermediate \\(y\\)-values as rows, along with a wrapper function that takes these along with the \\(x\\)-values and end points of our path before returning the total time taken. Every time this function is called, the inserted \\(y\\)-values are stored into our matrix.\nmax.iter \u0026lt;- 100000L # maximum number of iterations for convergence method\rintermed.y.count \u0026lt;- 0L\rintermed.y \u0026lt;- matrix(as.numeric(NA), ncol = N+1, nrow = max.iter)\rgetTime \u0026lt;- function(intermed.heights, inx, P1, P2){\rintermed.y.count \u0026lt;\u0026lt;- intermed.y.count + 1L\rintermed.y[intermed.y.count,] \u0026lt;\u0026lt;- c(P1[2],intermed.heights,P2[2])\rN \u0026lt;- length(intermed.heights)+1\rtraj \u0026lt;- data.frame(x = inx,\ry = intermed.y[intermed.y.count,],\rv = rep(NA, times = N+1),\ra = rep(NA, times = N+1),\rt = rep(NA, times = N+1))\rreturn(motion(traj)$t[nrow(traj)])\r}\rNow we may apply the optimisation function.\nset.seed(1) # for reproducability\rminima \u0026lt;- optim(par = seq(P1[2],P2[2], length.out = N+1)[2:N],\rfn = getTime,\rlower = rep(-5, times = N-1),\rupper = rep(P1[2]-1e-5, times = N-1),\rmethod = \u0026quot;L-BFGS-B\u0026quot;,\rinx = brach.path$x,\rP1 = P1,\rP2 = P2)\rFinally, we can create the animation:\ny \u0026lt;- as.vector(intermed.y[1:intermed.y.count,])\rx \u0026lt;- rep(brach.path$x,\rtimes = rep(intermed.y.count, N+1))\riter \u0026lt;- rep(1:intermed.y.count, times = N+1)\rplot.data \u0026lt;- data.frame(x = x, y = y, iter = iter)\ranim.optim \u0026lt;- ggplot() +\rgeom_path(data = brach.path, aes(x = x, y = y), colour = \u0026quot;red\u0026quot;) +\rgeom_point(data = brach.path, aes(x = x, y = y), colour = \u0026quot;red\u0026quot;) +\rgeom_path(data = plot.data, aes(x = x, y = y)) +\rgeom_point(data = plot.data, aes(x = x, y = y)) +\rcoord_fixed() +\rylim(min(c(brach.path$y,plot.data$y)), max(c(brach.path$y,plot.data$y))) +\rtransition_time(iter)\ranim.optim \u0026lt;- animate(anim.optim, renderer = gifski_renderer(),\rduration = 10, end_pause = 5, fps = 20, res = 100,\rwidth = 800, height = 400)\r\r","date":1581724800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1581724800,"objectID":"6bf39cafc451f8385b00454112040030","permalink":"/post/brachistochrone/","publishdate":"2020-02-15T00:00:00Z","relpermalink":"/post/brachistochrone/","section":"post","summary":"Consider a point \\(P_1\\) alongside another point \\(P_2\\) which lies below, but not directly below it. Which path allows a bead initially at rest, to slide frictionlessly from \\(P_1\\) to \\(P_2\\) with the least possible time \\(t\\) when subject to a constant downward gravitational force? This is known as the Brachistochrone problem and it is famous in the development of calculus.\n\rFigure 1: Simulated motion for different paths (time not to scale)\r\rThe solution to this problem is the Brachistochrone curve, which was found to be a cycloid.","tags":["Physics","Simulation","Optimisation","Animation","R"],"title":"The Brachistochrone","type":"post"},{"authors":null,"categories":null,"content":"All the following information is to the best of my knowledge.\nThis website does not require you to identify yourself. Information is collected by Google Analytics for analysing web traffic, although I do not have any access to this information other than in aggregated reports. This information is obtained by cookies, which to the best of my knowledge may be disabled by your web browser. In the Hugo framework settings for Google Analytics privacy I have set for your IP address to be randomised and for tracking to be disabled.\n","date":1550275200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1550275200,"objectID":"18d05a63a1c8d7ed973cc51838494e41","permalink":"/privacy/","publishdate":"2019-02-16T00:00:00Z","relpermalink":"/privacy/","section":"","summary":"All the following information is to the best of my knowledge.\nThis website does not require you to identify yourself. Information is collected by Google Analytics for analysing web traffic, although I do not have any access to this information other than in aggregated reports. This information is obtained by cookies, which to the best of my knowledge may be disabled by your web browser. In the Hugo framework settings for Google Analytics privacy I have set for your IP address to be randomised and for tracking to be disabled.","tags":null,"title":"Privacy Policy","type":"page"}]